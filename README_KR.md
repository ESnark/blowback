# Vite MCP 서버

Vite 개발 서버와 Cursor를 통합하는 Model Context Protocol(MCP) 서버로, Cursor AI 에이전트가 코드를 수정하고 Vite의 Hot Module Replacement 시스템을 통해 실시간 업데이트를 관찰할 수 있게 합니다.

## 주요 기능

- 🔄 실행 중인 Vite 개발 서버의 HMR 시스템에 연결
- 🔍 HMR 이벤트 및 업데이트 상태 모니터링
- 🌐 자동화된 브라우저를 통한 시각적 피드백 및 디버깅
- 🤖 Cursor AI 에이전트가 코드를 수정하고 실시간으로 결과 확인 가능

## 설치

```bash
npm install -g vite-mcp-server
```

또는 npx를 사용하여 직접 실행:

```bash
npx vite-mcp-server
```

## Cursor와 함께 사용하기

### 1. Cursor에서 설정하기

Cursor의 MCP 설정에 서버를 추가합니다:

```json
{
  "vite-hmr": {
    "command": "npx",
    "args": ["-y", "vite-mcp-server"]
  }
}
```

### 2. 연결 초기화하기

먼저 Vite 개발 서버에 연결을 초기화합니다:

```
Vite HMR 서버를 ws://localhost:5173/__hmr에 연결하고 프로젝트 루트를 /경로/내/프로젝트로 설정해주세요
```

Cursor는 `init-vite-connection` 도구를 실행하여 연결을 설정합니다.

### 3. 파일 업데이트 및 변경 사항 모니터링하기

이제 Cursor에게 파일 수정 및 HMR 상태 확인을 요청할 수 있습니다:

```
src/App.jsx 파일의 제목을 "Hello MCP and Vite!"로 변경해주세요
```

Cursor는 다음과 같은 작업을 수행합니다:
1. 현재 파일 내용 읽기
2. 파일 업데이트
3. `check-hmr-status` 도구를 사용하여 HMR 상태 확인

### 4. 브라우저 자동화 기능 사용하기

브라우저 자동화 기능을 사용하여 직접 브라우저를 보고 상호작용할 수도 있습니다:

```
http://localhost:5173에서 Vite 앱에 대한 브라우저 세션을 시작하고 로드 후 페이지 스크린샷을 캡처해주세요.
```

Cursor는 다음과 같은 작업을 수행합니다:
1. `start-browser` 도구를 사용하여 자동화된 Chrome 브라우저 시작
2. Vite 앱으로 이동
3. `capture-screenshot` 도구를 사용하여 스크린샷 캡처
4. 결과 표시

### 5. 체크포인트를 사용한 상태 확인

체크포인트 도구를 사용하여 개발 중 브라우저 상태를 캡처하고 확인할 수 있습니다:

```
"initial-state"라는 이름으로 현재 브라우저 상태의 체크포인트를 설정하고 자세한 비교를 위해 DOM 스냅샷을 포함해주세요.
```

나중에 변경 사항을 적용한 후 상태가 예상대로 변경되었는지 확인할 수 있습니다:

```
"initial-state" 체크포인트에 대해 브라우저 상태를 확인하고 무엇이 변경되었는지 알려주세요.
```

Cursor는 다음과 같은 작업을 수행합니다:
1. DOM 스냅샷과 함께 `set-checkpoint`를 사용하여 체크포인트 생성
2. 애플리케이션에 변경 사항 적용
3. `verify-checkpoint`를 사용하여 현재 상태와 이전 체크포인트를 비교
4. 상태 간의 세부 차이점 보고

## 사용 가능한 도구

이 MCP 서버는 다음과 같은 도구를 제공합니다:

| 도구 이름 | 설명 |
|-----------|-------------|
| `init-vite-connection` | 프로젝트의 개발 서버에 연결합니다 |
| `get-hmr-events` | 최근 HMR 이벤트를 가져옵니다 |
| `check-hmr-status` | HMR 상태를 확인합니다 |
| `start-browser` | 브라우저 인스턴스를 시작하고 Vite 개발 서버로 이동합니다 |
| `get-browser-console-logs` | 브라우저 세션에서 콘솔 로그를 가져오며, 선택적으로 필터링이 가능합니다 |
| `get-browser-console-errors` | 디버깅을 위해 브라우저 세션에서 오류 로그만 가져옵니다 |
| `monitor-browser-console` | 브라우저 콘솔 로그 모니터링을 시작하거나 중지합니다 |
| `capture-screenshot` | 현재 페이지 또는 특정 요소의 스크린샷을 캡처합니다 |
| `get-element-properties` | 특정 요소의 속성 및 상태 정보를 가져옵니다 |
| `get-element-styles` | 특정 요소의 스타일 정보를 가져옵니다 |
| `get-element-dimensions` | 특정 요소의 치수 및 위치 정보를 가져옵니다 |
| `monitor-network` | 지정된 시간 동안 브라우저의 네트워크 요청을 모니터링합니다 |
| `update-cursor-tracker` | 변경 사항을 추적하기 위해 브라우저에 메타 태그를 생성하거나 업데이트합니다 |
| `get-element-html` | 특정 요소와 그 자식 요소의 HTML 내용을 가져옵니다 |
| `execute-browser-commands` | 미리 정의된 브라우저 명령을 안전하게 실행합니다 |
| `set-checkpoint` | 나중에 확인할 수 있도록 현재 브라우저 상태의 이름이 지정된 체크포인트를 생성합니다 |
| `verify-checkpoint` | 현재 브라우저 상태가 이전에 생성된 체크포인트와 일치하는지 확인합니다 |

## 요구 사항

- Node.js 20 이상
- 실행 중인 Vite 개발 서버
- MCP 지원이 있는 Cursor
- Chrome 브라우저 (브라우저 자동화 기능 사용 시)

## 개발

```bash
# 저장소 복제
git clone https://github.com/yourusername/vite-mcp-server.git
cd vite-mcp-server

# 의존성 설치
npm install

# 프로젝트 빌드
npm run build

# 서버 시작
npm start
```

## 문제 해결

### 연결 문제

1. Vite 서버가 실행 중인지 확인하세요.
2. HMR WebSocket URL이 올바른지 확인하세요.
3. Cursor를 재시작하고 MCP 설정을 확인하세요.

### 브라우저 자동화 문제

1. Chrome이 컴퓨터에 설치되어 있는지 확인하세요.
2. 충분한 메모리와 CPU 리소스가 있는지 확인하세요.
3. 특정 요소의 스크린샷을 캡처할 때 CSS 선택자가 올바른지 확인하세요.

## 기본 작동 원리

1. MCP 서버는 Vite 개발 서버의 HMR WebSocket에 연결합니다.
2. Cursor는 MCP 프로토콜을 통해 서버와 통신합니다.
3. 파일이 수정되면 Vite의 HMR 시스템이 자동으로 변경 사항을 감지합니다.
4. MCP 서버는 HMR 이벤트를 수집하고 분석합니다.
5. 브라우저 자동화 기능을 사용하면 실제로 변경 사항이 어떻게 보이는지 확인할 수 있습니다.

## 아키텍처 및 데이터 흐름

MCP Vite HMR 서버는 여러 핵심 구성 요소가 함께 작동하는 모듈식 아키텍처를 따릅니다:

### 핵심 구성 요소

1. **MCP 서버**: Cursor에 도구를 제공하는 Model Context Protocol SDK 기반의 중앙 모듈입니다.

2. **Vite HMR 클라이언트**: Vite 개발 서버와 WebSocket 연결을 설정 및 유지하며 HMR 이벤트를 구독합니다.

3. **브라우저 자동화**: Puppeteer를 사용하여 Chrome을 제어하고 변경 사항을 시각적으로 검사할 수 있게 합니다.

4. **체크포인트 시스템**: 비교 및 테스트를 위해 브라우저 상태의 스냅샷을 유지합니다.

### 데이터 소스 및 상태 관리

서버는 여러 중요한 데이터 저장소를 유지합니다:

- **HMR 이벤트 기록**: Vite에서 발생한 최근 HMR 이벤트(업데이트, 오류)를 추적합니다.
- **콘솔 메시지 로그**: 디버깅을 위한 브라우저 콘솔 출력을 캡처합니다.
- **체크포인트 저장소**: DOM 스냅샷을 포함한 브라우저 상태의 이름이 지정된 스냅샷을 저장합니다.

### 통신 흐름

1. **Vite → MCP 서버**: 
   - Vite는 파일이 변경될 때 WebSocket을 통해 실시간 HMR 이벤트를 전송합니다.
   - 이벤트에는 업데이트(성공적인 변경) 및 오류(컴파일 실패)가 포함됩니다.

2. **MCP 서버 → Cursor**:
   - 서버는 HMR 이벤트를 구조화된 응답으로 변환합니다.
   - Cursor가 HMR 상태를 쿼리하고 스크린샷을 캡처하는 등의 도구를 제공합니다.

3. **브라우저 → MCP 서버**:
   - 시각적 변경 사항은 Puppeteer를 통해 캡처됩니다.
   - 디버깅을 위해 콘솔 출력 및 오류가 수집됩니다.

### 상태 유지

서버는 다음에 대한 참조 객체를 유지합니다:
- 현재 브라우저 및 페이지 인스턴스
- 활성 Vite 클라이언트 연결
- 프로젝트 루트 경로
- 최근 HMR 이벤트

이 아키텍처는 Cursor의 AI 기능과 Vite의 개발 환경 간의 원활한 통합을 가능하게 하여 HMR 이벤트와 시각적 확인을 통해 코드 변경에 대한 실시간 피드백을 제공합니다.

### 체크포인트 시스템의 작동 원리

체크포인트 시스템은 MCP Vite HMR 서버의 강력한 기능으로, 특정 시점의 브라우저 상태를 저장하고 나중에 비교할 수 있게 해줍니다.

#### 체크포인트 구조

각 체크포인트는 다음 정보를 포함합니다:
- **고유 ID**: 사용자가 지정하거나 자동 생성된 식별자
- **타임스탬프**: 체크포인트가 생성된 시간
- **해시 값**: 브라우저 상태를 추적하기 위한 고유 식별자
- **페이지 URL**: 현재 페이지의 URL
- **DOM 스냅샷(선택사항)**: 전체 또는 선택된 DOM 요소의 HTML 내용
- **설명(선택사항)**: 체크포인트의 목적이나 내용에 대한 설명

#### 체크포인트 생성 과정

체크포인트를 생성하는 과정은 다음과 같습니다:
1. `set-checkpoint` 도구가 호출되면 고유한 UUID 해시가 생성됩니다.
2. 브라우저에 메타 태그(`__vite_hmr_cursor`)가 추가되거나 업데이트되어 이 해시를 저장합니다.
3. 현재 페이지 URL이 기록됩니다.
4. `captureDOM` 옵션이 활성화된 경우, 현재 DOM의 스냅샷(HTML)이 캡처됩니다.
5. 이 모든 정보가 내부 Map 데이터 구조에 저장됩니다.
6. 메모리 관리를 위해 최대 20개의 최근 체크포인트만 유지됩니다.

#### 체크포인트 검증 메커니즘

체크포인트 검증은 다음 세 가지 주요 측면을 확인합니다:

1. **URL 일치 여부**: 현재 페이지 URL이 체크포인트 생성 시점의 URL과 동일한지 확인
2. **해시 검증**: 메타 태그의 해시 값이 체크포인트의 해시와 일치하는지 확인
3. **DOM 비교(선택사항)**: DOM 스냅샷이 있는 경우, 현재 DOM과 저장된 스냅샷을 비교

이 중 하나라도 불일치하면 상태가 변경되었음을 의미합니다.

#### 선택적 DOM 검증

DOM 검증은 두 가지 방식으로 수행할 수 있습니다:
- **전체 페이지 비교**: 문서 전체의 HTML을 비교합니다.
- **특정 요소 비교**: CSS 선택자를 사용하여 특정 요소만 비교합니다.

이를 통해 전체 페이지가 아닌 관심 있는 부분만 집중적으로 확인할 수 있습니다.

#### 체크포인트의 활용 사례

체크포인트 시스템은 다음과 같은 상황에서 특히 유용합니다:

- **UI 회귀 테스트**: 코드 변경 후 UI가 의도한 대로 변경되었는지 확인
- **디버깅**: 문제가 발생한 시점과 정상 작동 시점의 상태 비교
- **상태 추적**: 복잡한 상태 변화를 시각적으로 추적
- **협업**: 다른 개발자와 특정 상태를 공유하여 문제 해결

체크포인트 시스템은 HMR 이벤트 외에도 시각적 상태를 추적하는 추가 레이어를 제공하여 개발자가 코드 변경의 영향을 더 포괄적으로 이해할 수 있게 합니다.

## 라이선스

MIT
